> 参考文档: [深入Python import机制](http://sinhub.cn/2019/05/python-import-machinery-part-one/), [深入理解Python的import](https://www.kawabangga.com/posts/2340), [导入系统](https://docs.python.org/zh-cn/3/reference/import.html#import-hooks), [importlib---import的实现](https://docs.python.org/zh-cn/3/library/importlib.html)

## 术语

- **package 包**: 可以包含子模块或递归包含子包的module, 在Python中也是`module`类型, 但是含有`__path__`属性;

- **regular package 正规包**: 传统类型的package, 包含一个`__init__.py`文件的目录;

- **namespace package 命名空间包**: 仅被用作子包容器, 没有实体标识物, 没有`__init__.py`文件;

- **module 模块**: Python代码的一种组织单位, 可吧包含任意Python对象.

- **finder 查找器**: 查找被导入模块的loader的对象;

  - **meta path finder 元路径查找器**:
  - **path entery finder 路径入口查找器**:  任一可调用对象使用`sys.path_hooks`返回的finder;

- **loader 加载器**: 负责加载模块的对象, 必须定义名为`load_module()`的方法, 通常由`finder`返回.

- **importer 导入器**: 同时实现了finder和loader.

  

## 导入系统

### 模块
### 包
### 搜索

- Python会根据`import`的参数进行搜索, 例如`import foo.bar.baz`, Python先尝试导入`foo`, 然后是`foo.bar`, 最后是`foo.bar.baz`, 如果任何一个失败都会抛`ModuleNoFoundError`异常;
- **缓存**:
  - 导入搜索, 首先会检查`sys.modules`, 这里会缓存所有已导入的模块, 如果导入过 `foo.bar.baz`，则 `sys.modules` 将包含 `foo`, `foo.bar` 和 `foo.bar.baz` 三个模块;
  - 如果查到需要导入的模块, 则导入过程完成;
  - 如果查到模块, 但是值位`None`时, 也会抛出`ModuleNoFoundError`异常;
  - 可以使用`importlib.reload()`重新导入一个模块;
- 如果缓存中未查到指定模块, 则会通过`查找器`和`加载器`查找并加载模块;
- **查找器**: 
  - 查找器不直接加载模块, 而是返回一个模块规格说明, 这是对模块导入相关信息的封装;
  - **元路径查找器**:
    - 当指定模块在缓存中找不到时, Python会接着搜索`sys.meta_path`, 遍历取出查找器对象, 调用`find_spec(fullname, path=None, target=None)`方法;
    - `sys.meta_path`默认包含三种原路径查找器: `BuiltinImporter, FrozenImporter, PathFinder`
    - 例如导入`foo.bar.baz`, 在每个元路径查找器(`mpf`)上调用`mpf.find_spec('foo', None, None)`, 导入`foo`后, 第二次遍历调用`mpf.find_spec('foo.bar', foo.__path__, None)`, 导入`foo.bar`后, 遍历调用`mpf.find_spec('foo.bar.baz', foo.bar.__path__, None)`
  - **基于路径的查找器(path based finder) `PathFinder`**: 
    - 根据路径, 查找或加载Python模块和包. 
    - `sys.path`: 包搜索位置, 由`PYTHONPATH` 环境变量和其他一些数据初始化;
    - `sys.path`元素可以设置为: 文件系统路径, zip文件, url, 数据库查询等;
- **加载器**: 

### 加载

## importlib