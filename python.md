本文用于记录python知识点
##1.数据类型
- 整数
- 浮点数
- 字符串
- 布尔
- 空值
- list
- tuple
- dict
- set

##2.函数
### 1.内置函数
- abs()
- max()
- int()
- float()
- str()
- bool()
### 2.定义函数
- def

- pass

- 关键字参数

- `*param`：从此处开始直到结束的所有位置参数（Positional Arguments）都将被收集并汇聚成为一个成为"param"的元组；

- 命名关键字参数`**param` ：从此处开始直到结束的所有的==关键字参数==都将被收集并汇集为一个名为"param"的字典；

  ```python
  def f(**kw):
    print(kw)
   
  f(test1=1, test2=2)			# 输出：{‘test1’:1， ‘test2':2}
  # 或者
  d = {'test1':1, 'test2':2}
  f(**d)						# 输出：{‘test1’:1， ‘test2':2}
  ```

## 3.高级特定
- 切片:
- 迭代:
  - 能用`for`循环的对象都为可迭代的（`iterable`）；
  - ​
- 列表生成式:
  - `list(iterable)`函数，可以把一个可迭代对象转换为列表；
  - `[i for i in range(10)]`列表生成式，
- 生成器`generator`：通过边循环边计算生成数据，
  - 1.将列表生成式的`[]`换为`()`，如`a = (i for i in range(10))` a就是一个生成器；
  - 2.使用`yield ` ；
  - 可以通过`for`循环或`next()`取出生成器中的数据；
- 迭代器:
  - 可迭代对象`Iterable`：可以直接作用于`for`循环的对象，包括`list, tuple, dict, set, str, generator`等；可以用`isinstance(xxx, Iterable)`
  - 迭代器`Iterator`：可以被`next()`函数调用并不断返回下一个值的对象（生成器）；
  - `iter(iterable)`：将可迭代对象转变为迭代器；
- 特殊赋值:`a,b=b,a+b` 相当于`t=(b,a+b), a=t[0], b =t[1]`
- 迭代器和生成器：
  - 迭代器：任何实现了` __next__ `方法 （python2 是 next）的对象都可以称为迭代器，同列表的区别在于，构建迭代器的时候，不像列表把所有元素一次性加载到内存，而是以一种延迟计算方式返回元素。
  - 生成器：生成器本身还是一个迭代器，可以理解为方便构造的特殊迭代器。

## 4.函数式编程

-   一些点
    -   变量可以指向函数；
    -   函数名也是变量名；
-   高阶函数：函数可以接收另一个函数做为参数，还可以把函数作为结果返回。
-   `map()`
-   `filter(fuction, iterable)` 根据函数返回的`True或False`确定可迭代对象元素的去留（True，保留）；
-   `sorted(iterable, key, )`, 可以根据key指定的function排序，如`sorted(a, key=abs)`
-   函数作为返回值： 
-   匿名函数（lambda表达式）：只有一个表达式，返回值就是该表达式的结果。
-   装饰器：
-   匿名函数：

## 5.模块

-   模块：一个.py 文件就可以称为一个模块；
-   包：含有一些模块文件和一个`__init__.py`的文件；
-   包可以嵌套；
-   模块分为直接运行和导入两种情况，当模块直接运行时会把一个特殊变量`__name__`置位`__main__`;
-   作用域：模块中的有些希望仅仅在模块中使用的变量和函数，可以通过前缀`_`实现；
    -   一般`__xxx__`类型名称的变量，是特殊变量，可以被直接引用；例如`__name__, __author__`
    -   类似`_xxx`类型名称的变量，都是非公开的，不应该被直接引用。（但是可见的，引用不引用需要使用者自觉遵守）

## 6.面向对象

### 1.基本语法

- ```python
  class Student(objext):
    pass
  ```

  - 通过`class`关键字定义类；
  - 通过`( )` ：表明该类从哪继承；

- `__init__()`：类似C++中的构造函数；第一个参数必须是`self`；

- 访问控制：如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，python解释器会将其名称转换为`_类名__属性名`达到隐藏的目的；

- 在python中，变量名类似`__xxxx__`，双下划线开始，双下划线结束的，是特殊变量。特殊变量可以直接访问；

- 动态语言的“鸭子类型”， 它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那他就可以被看做是鸭子。

- 使用`type()`或`isinstance(obj, class_or_tuple)`判断类型；

- 使用`dir()`

- 实例属性和类属性：

  - 实例属性：给实例对象绑定属性的方法是通过实例变量，或者通过`self`变量；

  - 类属性：直接在`class`中定义属性，这种属性归类所有；

    ```python
    class Student(object):
      	def __init(self, name):
          	self.name = name			# 实例对象属性
        class = '302'					# 类属性
    ```

### 2.高级编程

-   创建类的示例后，可以给该实例绑定任何属性和方法，绑定的属性和方法只跟这个示例有关，跟类和其他实例无关；

    ```python
    s = Stuent()
    s.name = "lfeng"		# 任意绑定属性和方法 
    ```

-   限制实例的属性：通过`__slots__`变量，通过给该变量赋值一个元组，来规定允许绑定的属性名称；只对自身起作用，对通过继承的子类不起作用；

-   直接定义的属性无法做到数据类型，数据范围等的限制，一般需要依靠`get(), set()`函数的帮助；

    -   通过`@property`装饰器可以将一个方法转换为属性调用；
    -   `@property` 还会创建另一个装饰器`@xxx.setter`；负责把`xxx`方法变成属性赋值，不定义`setter`方法，则该属性就为只读的；

-   类中的特殊属性

    -   `__str__`
    -   `__iter__` ：如果一个类想被用于`for...in `循环，就必须实现一个`__iter__()`方法；该方法返回一个迭代对象，然后，Python的`for`循环就会不断调用该迭代对象的`__next__()` 方法拿到循环的下一个值；
    -   `__getitem__` ：实现该函数后，就能通过下标获取相应元素的值；
    -   `__getattr__` ：
    -   `__call__` ：
    -   `__str__` ：